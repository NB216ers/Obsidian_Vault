#input #question

## 系统性能
影响系统性能的计算机资源
### CPU
- 代码递归导致的无限循环
- 正则表达式引起的回溯
- JVM 频繁的 FULL GC
- 多线程编程造成的大量上下文切换 [[操作系统原理-7.11 上下文切换]]
###  内存
- Java 堆内存被占满，对象无法回收时，会导致内存溢出，内存泄露等
###  磁盘 I/O
- 磁盘 I/O 的读写速度本身就比较慢
###  网络
- 带宽，带宽过低，对于传输数据比较大，或者并发量大的系统，网络容易成为瓶颈
###  异常
- Java 中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响
###  数据库
- 数据库操作往往涉及磁盘 I/O 的读写。大量数据库操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。
###  锁竞争
- 锁的使用可能会带来上下文切换，从而给系统带来性能开销

## 响应时间/延迟
[[延迟]]

## 吞吐量
[[吞吐量]]

## 负载能力

当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。例如，当你对系统进行压测时，系统的响应时间会随着系统并发数的增加而延长，直到系统无法处理这么多请求，抛出大量错误时，就到了极限。

### CPU 利用率和系统负载这两个指标的关系？ 

[[系统负载]]代表单位时间内正在运行或等待的进程或线程数，代表了系统的繁忙程度，CPU 利用率则代表单位时间内一个线程或进程实时占用 CPU 的百分比。
我们知道，一个进程或者线程在运行时，未必都在实时的利用CPU的。

比如，在CPU密集型的情况下，系统的负载未必会高，但CPU的利用率肯定会高，一个线程/进程一直在计算，它对CPU的实时利用率是100%，而系统负载是0.1;

又比如，而对于 I/O 密集型的程序来说，有可能 CPU 的利用率不高，但系统的负载却会非常高，这是因为I/O经常引起阻塞，这样导致很多线程/进程被处于阻塞等待状态，处于等待的线程或进程也是属于负载线程/进程的。


### TPS QPS？

TPS (transaction per second)是单位时间内处理事务的数量，
QPS (query per second)是单位时间内请求的数量。

TPS代表一个事务的处理，可以包含了多次请求。很多公司用QPS作为接口吞吐量的指标，也有很多公司使用TPS作为标准，两者都能表现出系统的吞吐量的大小，TPS的一次事务代表一次用户操作到服务器返回结果，QPS的一次请求代表一个接口的一次请求到服务器返回结果。当一次用户操作只包含一个请求接口时，TPS和QPS没有区别。当用户的一次操作包含了多个服务请求时，这个时候TPS作为这次用户操作的性能指标就更具有代表性了。

### 异常会消耗系统性能？
如果没有生成堆栈追踪信息，不会有性能问题。一般业务异常避免生成堆栈追踪信息，
我们知道这个异常是什么原因，所以直接返回字符串就好了。而系统异常，一般都会生成堆栈追踪信息，以便追踪源头，更好的排查问题


### 使用 MySQL 经常会遇到业务需要实时导出大量业务数据的需求，那么如何在不影响业务和不分库的的情况满足业务实时导出大量数据的需求呢？

切忌在主库中操作这种报表类的导出，在写入和查询都在一个主库进行，会造成数据库性能瓶颈，严重的会导致数据库死锁。我们可以将数据库读写分离，写业务走主 (写)库，导出数据可以从从 (读)库导出。这种实现方式，首先能提高数据导出的性能，其次不影响写业务。如果你们公司有大数据中心，可以考虑将需要导出的数据实时同步到大数据中心，通过实时的流计算处理生成不同需求的业务数据。


### 最近段时间遇到端口被 CLOSE_WAIT 占用，重启后过了半天又重现，以前没有出现过，一般如何排查？

可以通过 tcpdump 抓包看看连接状态，分析是否是服务端的 FIN packet 没有发出去。

正常的关闭流程是：服务端在接收到客户端发送的关闭请求FIN后，会进入CLOSE_WAIT状态，同时发送ACK回去。在完成与客户端直接的通信操作之后，再向客户端发送FIN，进入LAST_ACK状态。

如果连接是CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做，导致没有发这个FIN packet。

建议确定关闭请求的四次握手，哪个环节出了问题，再去排查业务代码，可能是由于超时或者异常导致没有正常关闭连接。



java 性能调优实战\02-模块一概述