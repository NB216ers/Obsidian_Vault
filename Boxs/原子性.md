#java 

原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。
## “原子性”的本质是什么？

其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。

解决原子性问题，是要保证中间状态对外不可见。

## 什么破坏了原子性？
答案：**线程切换**,同一时刻，或一段时间，有多个线程修改了共享资源。
#### 操作系统的分时复用即提高了 CPU 的使用率，又提高了 I/O 的使用率。

>在一个时间片内，如果一个进程进行 I/O 操作，进程把自己标记为“休眠状态”，并让出 CPU 的使用权，等 I/O 操作完成，操作系统会把这个休眠进程唤醒，重新竞争 CPU 的使用权。
>进程在等待 I/O 时之所以释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样 CPU 的使用率就上来了；此外，如果这时有另外一个进程也进程 I/O 操作，I/O 操作就会排队，磁盘驱动在完成一个进程的 I/O 操作后，发现有排队的任务，就会立即启动下一个 I/O 操作, 这样 IO 的使用率也上来了。

不幸的是，分时复用导致的线程切换是产生 BUG 的源头。

我们需要在高级语言层面保证操作的原子性。



## 线程切换
如果禁用线程切换可以解决这个问题，操作系统的线程切换是依赖 CPU 中断的，所以禁用 CPU 中断就可以禁止线程切换。

单核时代，禁用 CPU 中断可以保证同一时刻针对竞态条件只有一个线程执行，即可以保证原子性。多核时代，两个线程可以并行执行，禁用 CPU 中断无法保证保证同一时刻针对共享变量的修改只有一个线程执行，即无法保证原子性。

<u>**同一时刻只有一个线程执行**</u>这个条件非常重要，我们称之为**互斥**。

如果我们能保证对共享变量的修改是互斥的，那么无论 CPU 是单核还是多核的，就都能保证原子性了。