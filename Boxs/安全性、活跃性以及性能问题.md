#input 

# 安全性

本质上就是正确性，正确性的含义就是程序按照我们期望的执行，不要让我们感到意外。
## 破坏安全性
共享数据由于<u>**数据竞争**</u>而产生变化会导致线程不安全。
很容易联想到，如果我能够做到不共享数据，或者数据状态不发生变化，就能保证线程安全。比如，线程本地存储（TLS）, 不变模式等。

<u>**竞态条件**</u>：指程序的执行结果依赖线程的执行顺序。

数据竞争和竞态条件都可以用**<u>互斥</u>**方案来解决，也就是 [[锁]]


# 活跃性问题
指某个操作无法执行下去，常见的**死锁**，**活锁**和**饥饿**。

![[锁#死锁（活跃性）]]


![[锁#活锁（活跃性）]]

![[锁#饥饿（活跃性）]]


# 性能问题
“锁”过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了。
性能估算：Amdahl (阿姆达尔)定律。
![[Pasted image 20230302015717.png]]

### 如何避免锁带来的性能问题呢？

很复杂，JCL 包里很大一部分原因就是要提升在某个特定领域的性能。
从方案层面上，
1. 使用无锁的算法和数据结构，比如 TLS（线程本地存储），[[Copy-on-Write]] (写入时复制)，乐观锁，jcl 的原子类等。
2. 减少锁的持有时间，[[锁#互斥锁本质上是将并行的程序串行化]],要增加并行度，一定要减少有锁的时间。
	1. 细粒度锁，ConcurrentHashMap 使用分段锁技术
	2. 读写锁，读是无锁，写的时候才互斥

### 性能指标
- [[吞吐量]]
- [[延迟]]：指的是从发出请求到收到响应的时间。
- 并发量：指的是能同时处理的请求数量，一般随着并发增加，延迟也会增加。