
# Mysql 性能
## Mysql 到底能支持多大的数据量？
>MySQL 3.22 限制的表大小为4GB。由于在MySQL 3.23 中使用了MyISAM 存储引擎，最大表尺寸增加到了65536TB（2567 – 1字节）。由于允许的表尺寸更大，MySQL数据库的最大有效表尺寸通常是由操作系统对文件大小的限制决定的，而不是由MySQL内部限制决定的。InnoDB 存储引擎将InnoDB 表保存在一个表空间内，该表空间可由数个文件创建。这样，表的大小就能超过单独文件的最大容量。表空间可包括原始磁盘分区，从而使得很大的表成为可能。表空间的最大容量为64TB。

事实上MySQL 能承受的数据量的多少主要和数据表的结构有关，并不是一个固定的数值。表的结构简单，则能承受的数据量相对比结构复杂时大些。

据D.V.B 团队以及Cmshelp 团队做CMS 系统评测时的结果来看，MySQL单表大约在2千万条记录（4G）下能够良好运行，经过数据库的优化后5千万条记录（10G）下运行良好。那么为什么国内的某些CMS厂商还会把其产品自身负载差的责任推给MySQL呢？

这对于MySQL是不公平的，那些CMS厂商非但没有把内核做好反而还在添加很多花哨的功能，最终导致其产品自身负载过低。他们并没有针对自身负载效果作出相应的数据库优化方案及标准，而是继续保留着复杂的结构造成对MySQL的资源无休止的浪费，最终导致了其负载上的缺陷，于是他们便充分发挥中国人的传统优势——变通：避重就轻的采用了所谓的分表式存储，虽然在一定程度上缓解了自身负载的缺陷，但是导致了网站后期维护以及资源上的浪费，这样做是否是长久之计呢？虽然他们解决了眼前的问题，但以后呢？难道想无休止的分表来达到目的？

用一个不恰当的比喻来形容，MySQL中的的表就像一块地，单表就相当于利用这块地盖高层建筑充分利用达到高人员负载，但分表就相当于用这块地盖了一间平房，如果为了达到高人员负载的话那就需要另开地皮达到目的，但是我们要思考，是地不够，还是他的能力不够，如此做法让人感到资源的浪费以及规划的严重缺陷。

分库分表周期长而风险高，应尽可能在当前结构上优化，比如升级硬件、迁移历史数据等等。

## 最大并发数
并发数是指同一时刻数据库能处理多少个请求，由  max-connections 和 max_user_connection 决定。 max-connections
是指MySQL 实例的最大连接数，上限值是 16384， max_user_connections 是指每个数据库用户的最大连接数。

MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：

>max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3%

查看最大连接数与响应最大连接数：
> show variables like '%max_connections%';  
 show variables like '%max_user_connections%';

在配置文件my.cnf中修改最大连接数:
>[mysqld]  
max_connections = 100  
max_used_connections = 20

## 查询耗时 0.5 秒
建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。

## 实施原则
相比NoSQL数据库，MySQL是个娇气脆弱的家伙。它就像体育课上的女同学，一点纠纷就和同学闹别扭(扩容难)，跑两步就气喘吁吁(容量小并发低)，常常身体不适要请假(SQL约束太多)。如今大家都会搞点分布式，应用程序扩容比数据库要容易得多，所以实施原则是**数据库少干活，应用程序多干活**。

-   充分利用但不滥用索引，须知索引也消耗磁盘和CPU。
    
-   不推荐使用数据库函数格式化数据，交给应用程序处理。
    
-   不推荐使用外键约束，用应用程序保证数据准确性。
    
-   写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。
    
-   适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。
    
-   不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。
    
-   预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。

# 数据表设计
## 数据类型

选择原则：更简单或者占用空间更小。
-   如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int。
-   如果字符串长度确定，采用char类型。
-   如果varchar能够满足，不采用text类型。
-   精度要求较高的使用decimal类型，也可以使用BIGINT，比如精确两位小数就乘以100后保存。
-   尽量采用timestamp而非datetime。


![图片](https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhoSNMK1rQe1nMzP7wHQpYxZpBpcFjJSa7Jskae0kzic1I7hO5MWC265XUb1hKh1H9bFxvq6JU9ho2g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

相比datetime，timestamp占用更少的空间，以UTC的格式储存自动转换时区。

## 避免空值 [^1]

很多字段使用 NULL 的原因大概如下：
1. NULL是创建数据表时默认的，初级或不知情的或怕麻烦的程序员不会注意这点
2. 很多人员都以为not null需要更多空间，其实这不是重点。
3. 重点是很多程序员觉得NULL在开发中不用去判断插入数据，写sql语句的时候更方便快捷。

MySQL 官方文档对 null 字段的说明
>NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.

《高性能mysql第二版》中也提到，Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYISAM中固定大小的索引变成可变大小的索引。

Null 列改为 非NULL 列可能导致页分裂

如果把NULL 改为非NULL ，这行数据的会变大，数据所处页分裂，如果后面的页都没有空间了，那么就会造成后面的页都会分裂，更新性能受到影响。

解决方式:

	可以使用nullable value替代。这种nullable value的设计是非常常见的，甚至有些存储是不支持null的，比如ES，那么要想表达这种方式，就是采用nullable value代替(ES官方文档)。

	所谓的nullable value就是对该字段没任何业务含义的值。比如age字段，可以使用任何小于等于0的值作为nullable value，年龄肯定是不可能小于等于0的。使用这种方式需要注意一下，在给前端展示的时候，要过滤掉nullable value，否则展示年龄=0，这是让用户一脸懵逼


## text 类型优化

由于text字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联



[^1]: [MySQL 一千个不用 Null 的理由 | 程序师 - 程序员、编程语言、软件开发、编程技术 (techug.com)](https://www.techug.com/post/you-should-not-use-null-in-mysql/)